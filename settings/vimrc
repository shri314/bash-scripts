" .vimrc file
"
" Author   : Shriram V
" Email    : shri314@yahoo.com
"
" use Vim defaults be used for options that have a different Vi and Vim default value.
set nocompatible

"set background=dark
"set background=light
set visualbell

"fzf setup
set runtimepath+=~/.fzf

execute pathogen#infect()

" Turn on syntax highlighting
syntax on

" Enable loading the plugin files for specific file types
filetype plugin on
filetype plugin indent on

autocmd BufNewFile,BufRead *.cgi    setl filetype=perl
autocmd BufNewFile,BufRead *.tt     setl filetype=html
autocmd BufNewFile,BufRead *.strace setl filetype=strace
autocmd BufNewFile,BufRead *.vim    setl filetype=vim
autocmd BufNewFile,BufRead *.c,*.h,*.C,*.cc,*.cpp,*.hpp,*.cxx,*.hxx,*.hh,*.ipp  setl filetype=cpp
autocmd BufNewFile,BufRead makefile*,Makefile*,*.mk  setl filetype=make
autocmd BufNewFile,BufRead *.am     setl filetype=automake

"Syntax & highlighting extensions
highlight Comment        term=bold ctermfg=lightblue guifg=#8000ff gui=bold
highlight StatusLine     ctermfg=lightblue ctermbg=white
highlight StatusLineNC   ctermfg=gray      ctermbg=black

"Tabs:
"disables tabulour disables the plugin entirely.
"let g:loadTabulous = 1
let tabulousLabelLeftStr  = '_/     '
let tabulousLabelRightStr = '     \_'

highlight TabLineFill   ctermfg=Yellow     ctermbg=Grey
highlight TabLine       ctermfg=Blue       ctermbg=Black
highlight TabLineSel    ctermfg=Red        ctermbg=Blue   term=bold

autocmd FileType cpp setl syntax=cpp11
autocmd FileType cpp highlight Member term=bold ctermfg=white gui=bold
autocmd FileType cpp syntax match Member /\<m_[_A-Za-z0-9]*\>/
"autocmd FileType python compiler pylint

" FOLD CONFIG
if exists("&fdm")
   set fdm=marker
   set fmr={,}
   set nofen
endif

" Ignore case in search patterns
set ignorecase

" Incremental Search
set incsearch

" Highlight search
set hlsearch

" Show ruler
set ruler

" Set the shell to use
if has("win32")
   if executable('bash.exe')
      set shell=bash.exe
   else
      set shell=cmd.exe
   endif
else
   set shell=bash
endif

" Show brace matching as you edit
set showmatch

set matchpairs+=<:>
"set matchpairs+==:;

" Don't consider : as part of words
set iskeyword-=:
autocmd FileType make setl iskeyword-=:
autocmd FileType perl setl iskeyword-=:

" Show working mode
set showmode

" Show the command
set showcmd

" Number of screen lines to use for the command-line
set cmdheight=1

" Number of screen lines to use for the command-line
"set winminwidth=0

" Number of screen lines to use for the command-line
"set winminheight=0

" Shift width when you press << or >> to indent a line.
set shiftwidth=4
"autocmd FileType java setl shiftwidth=4
"autocmd FileType python setl shiftwidth=4
autocmd FileType vim setl shiftwidth=3

" Number of spaces for a tab only for editing purpose
set softtabstop=-1

" Set Shift rounding off
set shiftround

" Patten matching
set magic

" Switch buffer to edit a new file, and use open file if it already open
"set switchbuf=useopen,split
set switchbuf=useopen

" Make program to use
if $ENV_MAKE_PRG != ""
   set makeprg=$ENV_MAKE_PRG
else
   set makeprg=make\ -s\ -w\ $*
endif

" Grep program to use
if $ENV_GREP_PRG != ""
   set grepprg=$ENV_GREP_PRG
else
   set grepprg="grep -HIne $* /dev/null"
endif

" working directory settings
"set autochdir

" Changes how backspace works.
set bs=eol,indent,start
"set bs=start

" Expand Tab
set expandtab
"set noexpandtab
autocmd FileType make setl noexpandtab

" Number of spaces for a tab
set tabstop=8
autocmd FileType java setl tabstop=8

"Error formats
autocmd FileType cpp  setl errorformat=#%m
autocmd FileType cpp  setl errorformat+=%f:%l:%c:\ %m,%f:%l:\ %m
autocmd FileType cpp  setl errorformat+=make:\ ***\ %m,In\ file\ included\ from\ %f:%l:
autocmd FileType cpp  setl errorformat+=%f:\ In[%*\\d]'%m':
autocmd FileType cpp  setl errorformat+=\^I\^Ifrom\ %f:%l%m
autocmd FileType cpp  setl errorformat+=%Dmake[%*\\d]:\ Entering\ directory\ `%f'
autocmd FileType cpp  setl errorformat+=%Xmake[%*\\d]:\ Leaving\ directory\ `%f'

autocmd FileType java setl errorformat=##%m(%f:%l)
autocmd FileType java setl errorformat+=#%m
autocmd FileType java setl errorformat+=make:\ ***\ %m
autocmd FileType java setl errorformat+=%A%f:%l:\ %msymbol\ ,
autocmd FileType java setl errorformat+=%A%f:%l:\ %m
autocmd FileType java setl errorformat+=%-Z%p^
autocmd FileType java setl errorformat+=%Clocation%m
autocmd FileType java setl errorformat+=%Csymbol\ %#%m
autocmd FileType java setl errorformat+=%-G%.%#

autocmd FileType yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab indentkeys-=0# indentkeys-=<:>

" lines longer than the width of the window will not wrap
set nowrap

" Searches does not wrap around the end of the file
set nowrapscan

" prevent automatic wrap folding while typing beyond 'margin'. I hate it
set formatoptions-=t

"Not always equal
set noequalalways

if $TEMP != ""
   " Directory for backup files
   set backupdir=$TEMP

   " Directory for swap files
   set directory=$TEMP
endif

" warn when a shell command is used while the buffer has changed
set warn

" Does not allows writing to any file with no need for "!" override
set nowriteany

" viminfo settings
set viminfo='1000,f1,<500,:500,@50,/100,h

" Set indent
set smartindent
set autoindent
autocmd FileType cpp  set cindent

" Set cryptmethod
set cryptmethod=blowfish

if has("win32")
   autocmd BufNewFile,GUIEnter * simalt~x
endif

set list
set listchars=tab:>-,trail:-
autocmd FileType git setl nolist
autocmd FileType diff setl nolist

" auto complete
"autocmd FileType java setlocal omnifunc=javacomplete#Complete

" man page support
source $HOME/.vim/manual.vim

" mouse settings
if exists("&mouse")
   "set mouse=a
   set mousemodel=popup
endif

" (Internal)
" Function to toggle the window size.
let g:ScrTog=0
function! ToggleScreenSize()
   if g:ScrTog == 1
      execute "normal \<C-W>="
      let g:ScrTog=0
   else
      vertical resize
      resize
      let g:ScrTog=1
   endif
endfunction

" (Internal)
function! QuickfixOpen()
   top copen 5
   setl wrap
endfunction

" (Internal)
" Function to toggle the window size.
let g:ErrTog=0
function! ToggleQuickFix()
   if g:ErrTog == 0
      call QuickfixOpen()
      let g:ErrTog=1
   else
      call QuickfixOpen()
      q
      let g:ErrTog=0
   endif
endfunction

let g:gitgutter_max_signs=3000  "allow a max of 3000 diffs in the gutter

" (Internal)
" Function to toggle the gutter
function! ToggleGutter()
   if index(split(&signcolumn, ','), "no") == -1
      set signcolumn=no
   else
      set signcolumn=auto
   endif
   echo 'signcolumn ='&signcolumn
endfunction

" Search path for opening files.
if $ENV_SEARCH_PATH != ""
   set path=$ENV_SEARCH_PATH
else
   set path=,,.,..,../../,./include,../include,./src,../src,/usr/local/include,/usr/include/g++-3,/usr/include
endif

let g:explVertical=1 "split vertically the explorer Window

"set guifont=Monospace\ Regular\ 11
"set guifont=Monospace\ Italic\ 11
autocmd GUIEnter * set guifont=Monaco:h14 | colorscheme desert

"F2 to Save file
nmap <F2> :w<CR>
imap <F2> <Esc>:w<CR><Esc>a

"F4 to list files in the project with the word under the cursor
map <F4>  :silent grep! -e "\<"<cword>"\>" *<CR>:call QuickfixOpen()<CR>:<BS><C-L>

"Shift-F4 to list files in the project with the word under the cursor ignoring the case
map <S-F4> :silent grep! -i -e "\<"<cword>"\>" *<CR>:call QuickfixOpen()<CR>:<BS><C-L>

"F5 to Stop highlighting words
map <F5>  :diffupdate<CR>:syntax sync fromstart<CR>:TlistUpdate<CR>:nohl<CR>

"Ctrl-F5 to stop highlighting words, and reload file (discard editing).
map <C-F5> :diffupdate<CR>:syntax sync fromstart<CR>:nohl<CR><Esc>:e!<CR>

"F6 to switch window
map <F6> <C-W>w<C-G>

"Shift-F6 to toggle window size
map <S-F6> :call ToggleScreenSize()<CR><C-G>

"- to decrease the current window height
map - <C-W>-

"= to increase the current window height
map = <C-W>+

"_ to decrease the current window width
map _ <C-W><

"+ to increase the current window width
map + <C-W>>

"F8 to Go to next error
map <F8>   :cn<CR>m'z.`'

"F7 to Go to previous error
map <F7>   :cp<CR>m'z.`'

"F11 to comment current line and go to next line
map <F11> 0i#<Esc>j
autocmd FileType vim  map <buffer> <F11> 0i"<Esc>j
autocmd FileType cpp  map <buffer> <F11> 0i//<Esc>j
autocmd FileType java map <buffer> <F11> 0i//<Esc>j

function! HLWord()
   if !exists("s:highlightword")
      execute "syn match HL \"\\\<" . expand("<cword>") . "\\\>\""
      "highlight HL term=bold,reverse cterm=bold,reverse ctermfg=4 ctermbg=7
      highlight HL term=bold,reverse cterm=bold ctermfg=0 ctermbg=10 gui=bold guifg=bg guibg=LightGreen
      let s:highlightword = 1
      echo 's:highlightword=1'
   else 
      syntax clear HL
      unlet s:highlightword
      echo 's:highlightword=0'
   endif 
endfunction 

" Highlight all instances of word under cursor, when idle.
" Useful when studying strange source code.
function! AutoHighlightToggle()
  let @/ = ''
  if exists('#auto_highlight')
    au! auto_highlight
    augroup! auto_highlight
    setl updatetime=4000
    echo 'Auto highlight current word: off'
    return 0
  else
    augroup auto_highlight
      au!
      au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
    augroup end
    setl updatetime=500
    echo 'Auto highlight current word: ON'
    return 1
  endif
endfunction

function! StubBeautify()
   echohl ErrorMsg | echo "Beautifier not configured..." | echohl None
endfunction

function! BeautifyUsingBcpp()
   if executable('bcpp')
      normal msHmt
      undojoin | %!bcpp -bnl -s -tbnl -i 3 -na -ylcnc -cc 33 2>/dev/null
      normal 'tzt`sa
   else
      call StubBeautify()
   endif
endfunction

function! BeautifyUsingAstyle()
   if executable('astyle')
      normal msHmt
      undojoin | %!astyle --style=allman --indent=spaces=3 --attach-extern-c --indent-switches --indent-namespaces --indent-classes --indent-preproc-define --indent-col1-comments --max-instatement-indent=40 --pad-oper --keep-one-line-blocks --convert-tabs --max-code-length=180 --lineend=linux --unpad-paren --align-pointer=type --align-reference=type 2>/dev/null | sed -e :a -e '/^\n*$/{$d;N;};/\n$/ba'
      normal 'tzt`sa
   else
      call StubBeautify()
   endif
endfunction

function! BeautifyUsingClangFormat()
   if executable('clang-format')
      normal msHmt
      undojoin | %!clang-format -style="{
         \AlignConsecutiveAssignments: 'true',
         \AlignOperands: 'true',
         \AlignAfterOpenBracket: Align,
         \BasedOnStyle: WebKit,
         \AlignTrailingComments: 'true',
         \AllowAllArgumentsOnNextLine: 'false',
         \AllowShortLambdasOnASingleLine: None,
         \AlwaysBreakTemplateDeclarations: 'Yes',
         \ConstructorInitializerAllOnOneLineOrOnePerLine: 'true',
         \ConstructorInitializerIndentWidth: '2',
         \KeepEmptyLinesAtTheStartOfBlocks: 'true',
         \MaxEmptyLinesToKeep: '3',
         \UseTab: Never
         \}"
      normal 'tzt`sa
   else
      call StubBeautify()
   endif
endfunction

function! BeautifyXml()
   if executable('xmllint')
      normal msHmt
      undojoin | %!xmllint --xmlout --format - 2>/dev/null
      normal 'tzt`sa
   else
      call StubBeautify()
   endif
endfunction

function! BeautifyPerl()
   if executable('perltidy')
      normal msHmt
      undojoin | %!perltidy -i=3 -nt -fnl -anl -bl -l=250 -bbs -bbc -bbb -mbl=2
      normal 'tzt`sa
   else
      call StubBeautify()
   endif
endfunction

function! ToggleSwitchBuffer()
   if index(split(&switchbuf, ','), "split") == -1
      set switchbuf+=split
   else
      set switchbuf-=split
   endif
   echo 'switchbuf ='&switchbuf
endfunction

"diffopt iwhite handling
if has('mac') && $VIM == '/usr/share/vim' | set diffopt-=internal | endif | set diffopt-=iwhite

function! ToggleSwitchDiffIWhite()
   if index(split(&diffopt, ','), "iwhite") == -1
      set diffopt+=iwhite
   else
      set diffopt-=iwhite
   endif
   echo 'diffopt ='&diffopt
endfunction


function! ConflictsNavigate(BackwardSearch, AcceptMatchCurPos, WrapAround)
   let srchFlags = ""
   if a:BackwardSearch    is v:true  | let srchFlags .= "b" | endif
   if a:AcceptMatchCurPos is v:true  | let srchFlags .= "c" | endif
   if a:WrapAround        is v:true  | let srchFlags .= "w" | endif
   if a:WrapAround        is v:false | let srchFlags .= "W" | endif
   return search('^[<]\{7\}', l:srchFlags)
endfunction


function! ConflictsGetInfo()
   let cp = line('.')
   let re = search("^[>]\\{7\\}", "cWn")
   if(cp > re)
      return v:null
   endif

   let lb = search("^[<]\\{7\\}", "cWnb")
   if(cp < lb)
      return v:null
   endif

   call cursor(lb, 0)
   let le = search("^[|]\\{7\\}", "Wn")
   let rb = search("^[=]\\{7\\}", "Wn")
   call cursor(cp, 0)

   let mb = le
   let me = rb

   if le == 0 | let le = rb | endif

   if lb != 0 && rb != 0 && re != 0
      let ret = {}
      if v:true  | let ret['left']   = {'first': lb, 'last': le} | endif
      if mb != 0 | let ret['parent'] = {'first': mb, 'last': me} | endif
      if v:true  | let ret['right']  = {'first': rb, 'last': re} | endif
      return ret
   else
      return v:null
   endif
endfunction


function! ConflictsInspect()
   if v:version < 801
      echohl ErrorMsg | :echo "This functionality requires Vim 8.1..." | :echohl None
      return
   endif

   let markers = ConflictsGetInfo()
   if markers is v:null
      echohl ErrorMsg | echo "No conflict under the cursor..." | echohl None
      return
   endif

   let done = 0
   try
      let textL = getbufline(bufnr("%"), markers["left"]["first"],   markers["left"]["last"])
      if has_key(markers, 'parent')
         let textP = getbufline(bufnr("%"), markers["parent"]["first"], markers["parent"]["last"])
      else
         let textP = v:null
      endif
      let textR = getbufline(bufnr("%"), markers["right"]["first"],  markers["right"]["last"])

      if bufnr('CVLeft')   > 0 | silent! bdelete! CVLeft   | endif
      if bufnr('CVParent') > 0 | silent! bdelete! CVParent | endif
      if bufnr('CVRight')  > 0 | silent! bdelete! CVRight  | endif

      tab new
      setl buftype=nofile noswapfile modifiable
      call setbufline(bufnr("%"), 1, textL)
      let g:CVLeft = textL[0]
      silent! file! CVLeft
      setl statusline=%!g:CVLeft
      :1d _
      :$d _
      :0
      setl nomodifiable number
      diffthis

      if textP isnot v:null
         vertical rightbelow new
         setl buftype=nofile noswapfile modifiable
         let g:CVParent = textP[0]
         silent! file! CVParent
         setl statusline=%!g:CVParent
         let r = setbufline(bufnr('CVParent'), 1, textP)
         :1d _
         :$d _
         :0
         setl nomodifiable number
         diffthis
      endif

      vertical rightbelow new
      setl buftype=nofile noswapfile modifiable
      silent! file! CVRight
      let g:CVRight = textR[-1]
      setl statusline=%!g:CVRight
      let r = setbufline(bufnr('CVRight'), 1, textR)
      :1d _
      :$d _
      :0
      diffthis
      setl nomodifiable number
      execute "normal \<c-w>="
      done = 1
   catch
      "if bufnr('CVLeft')   > 0 | silent! bdelete! CVLeft   | endif
      "if bufnr('CVParent') > 0 | silent! bdelete! CVParent | endif
      "if bufnr('CVRight')  > 0 | silent! bdelete! CVRight  | endif
      echo v:errmsg
   finally
       if done | echo 'conflict diff is ready in the tab...' | sleep 1 | endif
   endtry
endfunction


function! ConflictsPickLeft()
   if v:version < 801
      echohl ErrorMsg | :echo "This functionality requires Vim 8.1..." | :echohl None
      return
   endif

   let markers = ConflictsGetInfo()
   if markers is v:null
      echohl ErrorMsg | echo "No conflict under the cursor..." | echohl None
      return
   endif

   execute markers["left"]["last"] . "," . markers["right"]["last"] . "d _"
   execute markers["left"]["first"] . "d _"
endfunction


function! ConflictsPickRight()
   if v:version < 801
      echohl ErrorMsg | :echo "This functionality requires Vim 8.1..." | :echohl None
      return
   endif

   let markers = ConflictsGetInfo()
   if markers is v:null
      echohl ErrorMsg | echo "No conflict under the cursor..." | echohl None
      return
   endif

   execute markers["right"]["last"] . "d _"
   execute markers["left"]["first"] . "," . markers["right"]["first"] . "d _"
endfunction


function! ViewBothChanges(onto)
    "<(set -x; git diff -p --raw $V2...$V1 | _DIFF_filter $F) \
    "<(set -x; git show -p --raw $V2       | _DIFF_filter $F) \
    "    "+vert all" \
    "    "+file =/=$V1" \
    "    "+wincmd l" \
    "    "+file =/=$V2" \
    "    "+wincmd h"

   if has("gui_running")
       execute "!EDITOR=gvim _GIT_diff_diff " . a:onto . " REBASE_HEAD " . expand("%")
   else
       execute "!EDITOR=gvim _GIT_diff_diff " . a:onto . " REBASE_HEAD " . expand("%")
   endif
endfunction

map ?? :call ConflictsInspect()<CR>
map ?< :call ConflictsPickLeft()<CR>
map ?> :call ConflictsPickRight()<CR>
"map ?x :call ConflictsNavigate(v:false, v:false, v:false)<CR>
"map ?X :call ConflictsNavigate(v:true , v:false, v:false)<CR>



function! F12Help()
   echo "b   - beautify action\n"
   echo "b1  - beautify action for cpp (using clang)\n"
   echo "b2  - beautify action for cpp (using astyle)\n"
   echo "b3  - beautify action for cpp (using bcpp)\n"
   echo "F12 - show F12 help\n"
   echo "h   - toggle wordhighlight\n"
   echo "i   - toggle paste\n"
   echo "l   - toggle list\n"
   echo "n   - toggle number\n"
   echo "q   - toggle quickfix\n"
   echo "g   - toggle gutter\n"
   echo "s   - toggle switchbuf\n"
   echo "/   - toggle autohighlight\n"
   echo "c   - toggle diff iwhite\n"
   echo "t   - toggle show code listing\n"
endfunction

" Interesting customizations
" use qa to close all windows individually with q
cnoremap qa windo q

" use xa to save and close all windows individually with x
cnoremap xa windo x

" always keep the next word to be found at the center of the screen
"set scrolloff=5
noremap n nm'z.`'
noremap N Nm'z.`'

"https://stackoverflow.com/questions/23695727/vim-highlight-a-word-with-without-moving-cursor
nnoremap * *``
nnoremap # #``

"augroup CursorPosition
"   autocmd!
"   autocmd BufLeave * let b:winview = winsaveview()
"   autocmd BufEnter * if(exists('b:winview')) | call winrestview(b:winview) | endif
"augroup END


"F12<key> to apply special properties
map <F12><F12> :call F12Help()<CR>
map <F12>n :setl number!<CR>:echo 'number ='&number<CR>
map <F12>i :setl paste!<CR>:echo 'paste ='&paste<CR>
map <F12>l :setl list!<CR>:echo 'list ='&list<CR>
map <F12>c :call ToggleSwitchDiffIWhite()<CR>
map <F12>s :call ToggleSwitchBuffer()<CR>
map <F12>q :call ToggleQuickFix()<CR>:<BS><C-L>
map <F12>g :call ToggleGutter()<CR>
map <F12>t :TlistToggle<CR>
map <F12>h :call HLWord()<CR>
map <F12>/ :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
map <F12>b :call StubBeautify()<CR>
autocmd FileType cpp      map <buffer> <F12>b  :call BeautifyUsingClangFormat()<CR>
autocmd FileType cpp      map <buffer> <F12>b1 :call BeautifyUsingClangFormat()<CR>
autocmd FileType cpp      map <buffer> <F12>b2 :call BeautifyUsingAstyle()<CR>
autocmd FileType cpp      map <buffer> <F12>b3 :call BeautifyUsingBcpp()<CR>
autocmd FileType java     map <buffer> <F12>b  :call BeautifyUsingAstyle()<CR>
autocmd FileType perl     map <buffer> <F12>b  :call BeautifyPerl()<CR>
autocmd FileType xml,ant  map <buffer> <F12>b  :call BeautifyXml()<CR>

"imap <TAB> <C-P>
"autocmd FileType make unmap <TAB>

let Tlist_Process_File_Always = 1
set statusline=%<%f\ %h%m%r%([%{Tlist_Get_Tagname_By_Line()}]%)%=%-14.(%l,%c%V%)\ %P

" Always show status line
set laststatus=2

autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif

" Autoload .vimrc
" http://stackoverflow.com/questions/2400264/is-it-possible-to-apply-vim-configurations-without-restarting
augroup my_vimrc_hooks
   au!
   autocmd bufwritepost .vimrc echo 'sourcing .vimrc' | source ~/.vimrc
augroup end

" Enable virtualedit for visualblock
set virtualedit=block
vmap k  <Plug>SchleppUp
vmap j  <Plug>SchleppDown
vmap h  <Plug>SchleppLeft
vmap l  <Plug>SchleppRight
vmap Dk <Plug>SchleppDupLeft
vmap Dj <Plug>SchleppDupDown
vmap Dh <Plug>SchleppDupLeft
vmap Dl <Plug>SchleppDupRight

" Ignore some paths
set wildignore+=**/Debug/**
set wildignore+=**/Build/**
set wildignore+=**/build/**
set wildignore+=**/temp/**
set wildignore+=**/libs/**

if filereadable(expand('~/.vimrc.custom'))
   source ~/.vimrc.custom
endif

" Scan current file for specified word and open in quickfix
function! QfScan(needle)
   try
      silent! bdelete! QfSTmp
      new
      silent! file! QfSTmp
      execute 'r !grep -e ' a:needle ' -n -H #'
      normal gg
      normal dd
      hide
      execute 'cbuffer ' bufnr('QfSTmp')
      copen
   finally
      silent! bdelete! QfSTmp
   endtry
endfunction

" send the line under the cursor as keys to a tmux pane
function! TmuxExecLine(target_pane)
    silent! execute "!tmux send-keys -t " . a:target_pane . " '" . getline(".") . "' enter"
    silent! :/^[^# ]
    silent! normal z.
endfunction

function! AutoScript()
    map <buffer> <F9> :call TmuxExecLine('.')<CR>
endfunction
